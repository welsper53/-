<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>도전문제 - [구조분해, spread연산]</title>
</head>
<body>
    <script type="text/javascript">
        // 리액트 -> 태그와 자바스크립트코드 같이 쓴다
        // items는 배열이다 - 배열 안에 객체가 있다
        // 데이터베이스 연동없이 입력, 조회, 수정, 삭제 반복 연습
        let items = [
            { id: 1, name: "벤치프레스", count: 10 },
            { id: 2, name: "랫풀다운", count: 12 },
            { id: 3, name: "스쿼트", count: 30 },
        ];

        function tTable(iTems) {
            document.write("<table border='1' borderColor='blue'>")
            iTems.forEach((item) => {
                document.write("<tr>")
                document.write(`<td>${item.id}</td>`);
                document.write(`<td>${item.name}</td>`);
                document.write(`<td>${item.count}</td>`);
                document.write("</tr>")
            }) 
            document.write("</table>");
        }

        // 추가하기 - 전개연산자
        /*  배열 만 있을때
            객체 만 있을때
            배열 안에 객체가 있을 때    */
        document.write("<hr><b>추가하기-hap</b><br>")
        const item2 = {id: 5, name: "숨쉬기", count: 60}
        function addItem(item, item2) {
            return [...item, item2]
        }
        let hap = addItem(items, item2);
        tTable(hap)



        // 조회하기 - forEach
        /*  더블 쿼테이션과 싱글 쿼테이션
            문제는 같이 사용할 경우 바깥쪽을 더블, 안쪽을 싱글*/
        document.write("<hr><b>조회하기-items</b><br>")
        tTable(items)
        

        
        // 수정하기 - '추가하기' 동일하게 처리
        document.write("<hr><b>수정하기</b><br>")

        // prompt로 받으면 반환값이 문자열이다 <- (===, !==은 타입도 따지기 때문)
        // let result = window.prompt("수정하고자 하는 id를 입력하세요.");
        // alert('사용자가 선택한 아이디는 ' + result + '입니다.');
        let result = 1

        // arr.filter(callback(element[, index[, array]])[, thisArg])
        // filter함수는 조건을 수렴하는 것만 남겨서 새로운 배열을 반환한다
        let xx = [...items]
        xx.forEach((item) => {
            if(item.id === parseInt(result)) {
                xx = items.filter(item => item.id !== parseInt(result))
                xx = [...xx, { id: `${parseInt(result)}`, name: "덤벨프레스", count: 100 }]
            }
        }) ;

        // xx.splice(0, 1, { id: 1, name: "덤벨프레스", count: 1000 })
        tTable(xx)


        
        // 삭제하기 - filter함수
        /*  대화형 프로그래밍 처리 훈련 */
        document.write("<hr><b>삭제하기-items</b><br>");

        // prompt로 받으면 반환값이 문자열이다 <- (===, !==은 타입도 따지기 때문)
        // let result2 = window.prompt("삭제하고자 하는 id를 입력하세요.");
        let result2 = 1
        // alert('사용자가 선택한 아이디는 ' + result2 + '입니다.');

        // arr.filter(callback(element[, index[, array]])[, thisArg])
        // filter함수는 조건을 수렴하는 것만 남겨서 새로운 배열을 반환한다
        let delItems = items.filter((object) => object.id != result2);
        tTable(delItems)
    </script>
</body>
</html>